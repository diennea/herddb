/*
 Licensed to Diennea S.r.l. under one
 or more contributor license agreements. See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership. Diennea S.r.l. licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.

 */
package herddb.server;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.atomic.AtomicLong;
import java.util.logging.Level;
import java.util.logging.Logger;

import herddb.backup.DumpedLogEntry;
import herddb.codec.RecordSerializer;
import herddb.core.HerdDBInternalException;
import herddb.core.RunningStatementInfo;
import herddb.core.RunningStatementsStats;
import herddb.core.TableManager;
import herddb.core.TableSpaceManager;
import herddb.core.stats.ConnectionsInfo;
import herddb.log.LogSequenceNumber;
import herddb.model.DDLStatementExecutionResult;
import herddb.model.DMLStatementExecutionResult;
import herddb.model.DataScanner;
import herddb.model.DataScannerException;
import herddb.model.DuplicatePrimaryKeyException;
import herddb.model.GetResult;
import herddb.model.Index;
import herddb.model.NotLeaderException;
import herddb.model.Record;
import herddb.model.ScanResult;
import herddb.model.Statement;
import herddb.model.StatementEvaluationContext;
import herddb.model.StatementExecutionException;
import herddb.model.StatementExecutionResult;
import herddb.model.Table;
import herddb.model.TableAwareStatement;
import herddb.model.Transaction;
import herddb.model.TransactionContext;
import herddb.model.TransactionResult;
import herddb.model.commands.BeginTransactionStatement;
import herddb.model.commands.CommitTransactionStatement;
import herddb.model.commands.RollbackTransactionStatement;
import herddb.model.commands.SQLPlannedOperationStatement;
import herddb.model.commands.ScanStatement;
import herddb.network.Channel;
import herddb.network.ChannelEventListener;
import herddb.network.ServerSideConnection;
import herddb.proto.Pdu;
import herddb.proto.PduCodec;
import static herddb.proto.PduCodec.TxCommand.TX_COMMAND_BEGIN_TRANSACTION;
import static herddb.proto.PduCodec.TxCommand.TX_COMMAND_COMMIT_TRANSACTION;
import static herddb.proto.PduCodec.TxCommand.TX_COMMAND_ROLLBACK_TRANSACTION;
import herddb.security.sasl.SaslNettyServer;
import herddb.sql.TranslatedQuery;
import herddb.utils.Bytes;
import herddb.utils.DataAccessor;
import herddb.utils.RawString;
import herddb.utils.TuplesList;
import io.netty.buffer.ByteBuf;
import java.io.EOFException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.BiConsumer;

/**
 * Handles a client Connection
 *
 * @author enrico.olivelli
 */
public class ServerSideConnectionPeer implements ServerSideConnection, ChannelEventListener {

    private static final Logger LOGGER = Logger.getLogger(ServerSideConnectionPeer.class.getName());
    private static final AtomicLong IDGENERATOR = new AtomicLong();
    private final long id = IDGENERATOR.incrementAndGet();
    private final Channel channel;
    private final Server server;
    private final ServerSidePreparedStatementCache preparedStatements;
    /**
     * Open scanners. The ID is generated by the client
     */
    private final ConcurrentMap<Long, ServerSideScannerPeer> scanners = new ConcurrentHashMap<>();
    private final ConcurrentMap<RawString, Set<Long>> openTransactions = new ConcurrentHashMap<>();
    private volatile boolean authenticated;
    private volatile SaslNettyServer saslNettyServer;
    private final String address;
    private volatile String username = "";
    private final long connectionTs = System.currentTimeMillis();

    public ServerSideConnectionPeer(Channel channel, Server server) {
        this.channel = channel;
        this.channel.setMessagesReceiver(this);
        this.server = server;
        this.address = channel.getRemoteAddress();
        this.preparedStatements = server.getManager().getPreparedStatementsCache();
    }

    @Override
    public long getConnectionId() {
        return id;
    }

    @Override
    public void requestReceived(Pdu message, Channel _channel) {
        // message is handled by current thread
        boolean releaseMessageSync = true;
        try {
            LOGGER.log(Level.FINEST, "messageReceived {0}", message);

            switch (message.type) {
                case Pdu.TYPE_EXECUTE_STATEMENT: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    releaseMessageSync = false;
                    handleExecuteStatement(message, _channel);
                }
                break;
                case Pdu.TYPE_PREPARE_STATEMENT: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    releaseMessageSync = false;
                    handlePrepareStatement(message, _channel);
                }
                break;
                case Pdu.TYPE_EXECUTE_STATEMENTS: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    releaseMessageSync = false;
                    handleExecuteStatements(message, _channel);
                }
                break;
                case Pdu.TYPE_SASL_TOKEN_MESSAGE_REQUEST: {
                    handleSaslTokenMessageRequest(message, _channel);
                }
                break;
                case Pdu.TYPE_SASL_TOKEN_MESSAGE_TOKEN: {
                    handleSaslTokenMessage(message, _channel);
                }
                break;
                case Pdu.TYPE_TX_COMMAND: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    releaseMessageSync = false;
                    handleTxCommand(message, _channel);
                }
                break;
                case Pdu.TYPE_OPENSCANNER: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    handleOpenScanner(message, _channel);

                }
                break;
                case Pdu.TYPE_FETCHSCANNERDATA: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    handleFetchScannerData(message, _channel);
                }
                break;
                case Pdu.TYPE_CLOSESCANNER: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    handleCloseScanner(message, _channel);
                }
                break;
                case Pdu.TYPE_REQUEST_TABLESPACE_DUMP: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    handleRequestTablespaceDump(message, _channel);
                }
                break;
                case Pdu.TYPE_REQUEST_TABLE_RESTORE: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    handleRequestTableRestore(message, _channel);
                }
                break;
                case Pdu.TYPE_PUSH_TABLE_DATA: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    handlePushTableData(message, _channel);
                }
                break;
                case Pdu.TYPE_TABLE_RESTORE_FINISHED: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    handleTableRestoreFinished(message, _channel);
                }
                break;
                case Pdu.TYPE_RESTORE_FINISHED: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    handleRestoreFinished(message, _channel);
                }
                break;
                case Pdu.TYPE_PUSH_TXLOGCHUNK: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    handlePushTxLogChunk(message, _channel);
                }
                break;
                case Pdu.TYPE_PUSH_TRANSACTIONSBLOCK: {
                    if (!authenticated) {
                        sendAuthRequiredError(_channel, message);
                        break;
                    }
                    handlePushTransactionsBlock(message, _channel);
                }
                break;
                default:
                    _channel.sendReplyMessage(message.messageId,
                            PduCodec.ErrorResponse.write(message.messageId, "unsupported message type " + message.type));
            }
        } finally {
            if (releaseMessageSync) {
                message.close();
            }
        }
    }

    private void handleRequestTableRestore(Pdu message, Channel _channel) {
        try {
            long dumpLedgerId = PduCodec.RequestTableRestore.readLedgerId(message);
            long dumpOffset = PduCodec.RequestTableRestore.readOffset(message);
            String tableSpace = PduCodec.RequestTableRestore.readTablespace(message);
            byte[] table = PduCodec.RequestTableRestore.readTableDefinition(message);
            Table tableSchema = Table.deserialize(table);
            tableSchema = Table
                    .builder()
                    .cloning(tableSchema)
                    .tablespace(tableSpace)
                    .build();
            server.getManager()
                    .getTableSpaceManager(tableSpace)
                    .beginRestoreTable(tableSchema.serialize(), new LogSequenceNumber(dumpLedgerId, dumpOffset));
            ByteBuf res = PduCodec.AckResponse.write(message.messageId);
            _channel.sendReplyMessage(message.messageId, res);
        } catch (StatementExecutionException err) {
            ByteBuf res = composeErrorResponse(message.messageId, err);
            _channel.sendReplyMessage(message.messageId, res);
        }
    }

    private static ByteBuf composeErrorResponse(long messageId, Throwable err) {
        return PduCodec.ErrorResponse.write(messageId, err, err instanceof NotLeaderException, false);
    }

    private void handleTableRestoreFinished(Pdu message, Channel _channel) {
        try {
            String tableSpace = PduCodec.TableRestoreFinished.readTablespace(message);
            String table = PduCodec.TableRestoreFinished.readTableName(message);
            List<byte[]> _indexes = PduCodec.TableRestoreFinished.readIndexesDefinition(message);
            int numIndexes = _indexes.size();
            List<Index> indexes = new ArrayList<>(numIndexes);
            for (int i = 0; i < numIndexes; i++) {
                indexes.add(Index.deserialize(_indexes.get(i)));
            }
            LOGGER.log(Level.INFO, "tableRestoreFinished, table {0}, with {1} indexes", new Object[]{table, indexes.size()});

            server.getManager()
                    .getTableSpaceManager(tableSpace)
                    .restoreTableFinished(table, indexes);

            ByteBuf res = PduCodec.AckResponse.write(message.messageId);
            _channel.sendReplyMessage(message.messageId, res);
        } catch (StatementExecutionException err) {
            ByteBuf res = composeErrorResponse(message.messageId, err);
            _channel.sendReplyMessage(message.messageId, res);
        }
    }

    private void handleRestoreFinished(Pdu message, Channel _channel) {
        try {
            String tableSpace = PduCodec.TableRestoreFinished.readTablespace(message);

            server.getManager()
                    .getTableSpaceManager(tableSpace)
                    .restoreFinished();

            ByteBuf res = PduCodec.AckResponse.write(message.messageId);
            _channel.sendReplyMessage(message.messageId, res);
        } catch (StatementExecutionException err) {
            ByteBuf res = composeErrorResponse(message.messageId, err);
            _channel.sendReplyMessage(message.messageId, res);
        }
    }

    private void handlePushTableData(Pdu message, Channel _channel) {
        try {
            String tableSpace = PduCodec.PushTableData.readTablespace(message);
            String table = PduCodec.PushTableData.readTablename(message);

            long _start = System.currentTimeMillis();
            List<Record> records = new ArrayList<>();
            PduCodec.PushTableData.readRecords(message, (key, value) -> {
                records.add(new Record(
                        Bytes.from_array(key),
                        Bytes.from_array(value)));
            });

            LOGGER.log(Level.INFO, "Received {0} records for restore of table {1} in tableSpace {2}", new Object[]{records.size(), table, tableSpace});
            TableManager tableManager = (TableManager) server.getManager()
                    .getTableSpaceManager(tableSpace)
                    .getTableManager(table);
            tableManager.writeFromDump(records);
            long _stop = System.currentTimeMillis();
            LOGGER.log(Level.INFO, "Time restore {0} records: data {1} ms", new Object[]{records.size(), _stop - _start});
            ByteBuf res = PduCodec.AckResponse.write(message.messageId);
            _channel.sendReplyMessage(message.messageId, res);
        } catch (StatementExecutionException err) {
            ByteBuf res = composeErrorResponse(message.messageId, err);
            _channel.sendReplyMessage(message.messageId, res);
        }
    }

    private void handlePushTxLogChunk(Pdu message, Channel _channel) {
        try {
            String tableSpace = PduCodec.PushTxLogChunk.readTablespace(message);

            List<DumpedLogEntry> entries = new ArrayList<>();
            PduCodec.PushTxLogChunk.readRecords(message, (key, value) -> {
                entries.add(new DumpedLogEntry(
                        LogSequenceNumber.deserialize(key),
                        value));
            });

            LOGGER.log(Level.INFO, "Received {0} records for restore of txlog in tableSpace {1}", new Object[]{entries.size(), tableSpace});

            server.getManager().getTableSpaceManager(tableSpace)
                    .restoreRawDumpedEntryLogs(entries);

            ByteBuf res = PduCodec.AckResponse.write(message.messageId);
            _channel.sendReplyMessage(message.messageId, res);
        } catch (StatementExecutionException | EOFException err) {
            ByteBuf res = composeErrorResponse(message.messageId, err);
            _channel.sendReplyMessage(message.messageId, res);
        }
    }

    private void handlePushTransactionsBlock(Pdu message, Channel _channel) {
        try {
            String tableSpace = PduCodec.PushTransactionsBlock.readTablespace(message);

            List<Transaction> entries = new ArrayList<>();
            PduCodec.PushTransactionsBlock.readTransactions(message, (value) -> {
                entries.add(Transaction.deserialize(tableSpace, value));
            });

            LOGGER.log(Level.INFO, "Received " + entries.size() + " records for restore of transactions in tableSpace " + tableSpace);

            server.getManager().getTableSpaceManager(tableSpace).restoreRawDumpedTransactions(entries);

            ByteBuf res = PduCodec.AckResponse.write(message.messageId);
            _channel.sendReplyMessage(message.messageId, res);
        } catch (StatementExecutionException err) {
            ByteBuf res = composeErrorResponse(message.messageId, err);
            _channel.sendReplyMessage(message.messageId, res);
        }
    }

    private void handleOpenScanner(Pdu message, Channel _channel) {

        long txId = PduCodec.OpenScanner.readTx(message);

        String tableSpace = PduCodec.OpenScanner.readTablespace(message);
        long statementId = PduCodec.OpenScanner.readStatementId(message);
        String query
                = statementId > 0 ? preparedStatements.resolveQuery(tableSpace, statementId)
                        : PduCodec.OpenScanner.readQuery(message);
        if (query == null) {
            ByteBuf error = PduCodec.ErrorResponse.writeMissingPreparedStatementError(message.messageId, "bad statement id: " + statementId);
            _channel.sendReplyMessage(message.messageId, error);
            return;
        }

        long scannerId = PduCodec.OpenScanner.readScannerId(message);

        int fetchSize = PduCodec.OpenScanner.readFetchSize(message);
        if (fetchSize <= 0) {
            fetchSize = 10;
        }
        int maxRows = PduCodec.OpenScanner.readMaxRows(message); // default 0

        PduCodec.ObjectListReader parametersReader = PduCodec.OpenScanner.startReadParameters(message);
        List<Object> parameters = new ArrayList<>(parametersReader.getNumParams());
        for (int i = 0; i < parametersReader.getNumParams(); i++) {
            parameters.add(parametersReader.nextObject());
        }
        if (LOGGER.isLoggable(Level.FINER)) {
            LOGGER.log(Level.FINER, "openScanner txId+" + txId + ", fetchSize " + fetchSize + ", maxRows " + maxRows + "," + query + " with " + parameters);
        }
        RunningStatementsStats runningStatements = server.getManager().getRunningStatements();
        RunningStatementInfo statementInfo = new RunningStatementInfo(query,
                System.currentTimeMillis(), tableSpace, "", 1);
        try {
            TranslatedQuery translatedQuery = server
                    .getManager()
                    .getPlanner().translate(tableSpace,
                            query, parameters, true, true, false, maxRows);

            if (LOGGER.isLoggable(Level.FINEST)) {
                LOGGER.log(Level.FINEST, "{0} -> {1}", new Object[]{query, translatedQuery.plan.mainStatement});
            }

            TransactionContext transactionContext = new TransactionContext(txId);
            if (translatedQuery.plan.mainStatement instanceof SQLPlannedOperationStatement
                    || translatedQuery.plan.mainStatement instanceof ScanStatement) {
                runningStatements.registerRunningStatement(statementInfo);
                ScanResult scanResult = (ScanResult) server.getManager().executePlan(translatedQuery.plan, translatedQuery.context, transactionContext);
                DataScanner dataScanner = scanResult.dataScanner;

                ServerSideScannerPeer scanner = new ServerSideScannerPeer(dataScanner);

                String[] columns = dataScanner.getFieldNames();
                List<DataAccessor> records = dataScanner.consume(fetchSize);
                TuplesList tuplesList = new TuplesList(columns, records);
                boolean last = dataScanner.isFinished();
                if (LOGGER.isLoggable(Level.FINEST)) {
                    LOGGER.log(Level.FINEST, "sending first {0} records to scanner {1} query {2}", new Object[]{records.size(), scannerId, query});
                }
                if (!last) {
                    scanners.put(scannerId, scanner);
                }
                ByteBuf result = PduCodec.ResultSetChunk.write(message.messageId, tuplesList, last, dataScanner.transactionId);
                _channel.sendReplyMessage(message.messageId, result);
            } else {
                ByteBuf error = PduCodec.ErrorResponse.write(message.messageId, "unsupported query type for scan " + query + ": PLAN is " + translatedQuery.plan);
                _channel.sendReplyMessage(message.messageId, error);
            }
        } catch (DataScannerException  | StatementExecutionException err) {
            LOGGER.log(Level.SEVERE, "error on scanner " + scannerId + ": " + err, err);
            scanners.remove(scannerId);
            ByteBuf error = composeErrorResponse(message.messageId, err);
            _channel.sendReplyMessage(message.messageId, error);
        } finally {
            runningStatements.unregisterRunningStatement(statementInfo);
        }
    }

    private void handleFetchScannerData(Pdu message, Channel _channel) {
        long scannerId = PduCodec.FetchScannerData.readScannerId(message);
        int fetchSize = PduCodec.FetchScannerData.readFetchSize(message);
        if (fetchSize <= 0) {
            fetchSize = 10;
        }
        ServerSideScannerPeer scanner = scanners.get(scannerId);
        if (scanner != null) {
            try {
                DataScanner dataScanner = scanner.getScanner();
                List<DataAccessor> records = dataScanner.consume(fetchSize);
                String[] columns = dataScanner.getFieldNames();
                TuplesList tuplesList = new TuplesList(columns, records);

                boolean last = false;
                if (dataScanner.isFinished()) {
                    LOGGER.log(Level.FINEST, "unregistering scanner {0}, resultset is finished", scannerId);
                    scanners.remove(scannerId);
                    last = true;
                }
//                        LOGGER.log(Level.SEVERE, "sending " + converted.size() + " records to scanner " + scannerId);
                ByteBuf result = PduCodec.ResultSetChunk.write(message.messageId, tuplesList, last, dataScanner.transactionId);
                _channel.sendReplyMessage(message.messageId, result);
            } catch (DataScannerException err) {
                ByteBuf error = composeErrorResponse(message.messageId, err);
                _channel.sendReplyMessage(message.messageId, error);
            }
        } else {
            ByteBuf error = PduCodec.ErrorResponse.write(message.messageId, "no such scanner " + scannerId);
            _channel.sendReplyMessage(message.messageId, error);
        }
    }

    private void handleCloseScanner(Pdu message, Channel _channel) {

        long scannerId = PduCodec.CloseScanner.readScannerId(message);

        LOGGER.log(Level.SEVERE, "remove scanner {0} as requested by client", scannerId);
        ServerSideScannerPeer removed = scanners.remove(scannerId);
        if (removed != null) {
            removed.clientClose();
            ByteBuf error = PduCodec.AckResponse.write(message.messageId);
            _channel.sendReplyMessage(message.messageId, error);
        } else {
            ByteBuf error = PduCodec.ErrorResponse.write(message.messageId, "no such scanner " + scannerId);
            _channel.sendReplyMessage(message.messageId, error);
        }
    }

    private void sendAuthRequiredError(Channel _channel, Pdu message) {
        ByteBuf error = PduCodec.ErrorResponse.write(message.messageId,
                "autentication required (client " + channel + ")");
        _channel.sendReplyMessage(message.messageId, error);
    }

    private void handleRequestTablespaceDump(Pdu message, Channel _channel) {
        String dumpId = PduCodec.RequestTablespaceDump.readDumpId(message);
        int fetchSize = PduCodec.RequestTablespaceDump.readFetchSize(message);
        if (fetchSize <= 0) {
            fetchSize = 10;
        }
        String tableSpace = PduCodec.RequestTablespaceDump.readTablespace(message);
        boolean includeTransactionLog = PduCodec.RequestTablespaceDump.readInludeTransactionLog(message);
        server.getManager().dumpTableSpace(tableSpace, dumpId, message, _channel, fetchSize, includeTransactionLog);
    }

    private void handleExecuteStatements(Pdu message, Channel _channel) {
        long txId = PduCodec.ExecuteStatements.readTx(message);
        long transactionId = txId;
        String tableSpace = PduCodec.ExecuteStatements.readTablespace(message);
        long statementId = PduCodec.ExecuteStatements.readStatementId(message);
        String query
                = statementId > 0 ? preparedStatements.resolveQuery(tableSpace, statementId)
                        : PduCodec.ExecuteStatements.readQuery(message);
        if (query == null) {
            ByteBuf error = PduCodec.ErrorResponse.writeMissingPreparedStatementError(message.messageId, "bad statement id: " + statementId);
            _channel.sendReplyMessage(message.messageId, error);
            message.close();
            return;
        }
        boolean returnValues = PduCodec.ExecuteStatements.readReturnValues(message);
        PduCodec.ListOfListsReader statementParameters = PduCodec.ExecuteStatements.startReadStatementsParameters(message);
        int numStatements = statementParameters.getNumLists();
        List<List<Object>> batch = new ArrayList<>(numStatements);
        for (int i = 0; i < numStatements; i++) {
            PduCodec.ObjectListReader parametersReader = statementParameters.nextList();
            List<Object> batchParams = new ArrayList<>(parametersReader.getNumParams());
            for (int j = 0; j < parametersReader.getNumParams(); j++) {
                batchParams.add(parametersReader.nextObject());
            }
            batch.add(batchParams);
        }
        RunningStatementsStats runningStatements = server.getManager().getRunningStatements();
        RunningStatementInfo statementInfo = new RunningStatementInfo(query, System.currentTimeMillis(), tableSpace, "", numStatements);
        try {

            List<TranslatedQuery> queries = new ArrayList<>();
            for (int i = 0; i < numStatements; i++) {
                List<Object> parameters = batch.get(i);
                TranslatedQuery translatedQuery = server
                        .getManager()
                        .getPlanner().translate(tableSpace, query,
                                parameters, false, true, returnValues, -1);
                queries.add(translatedQuery);
            }

            List<Long> updateCounts = new CopyOnWriteArrayList();
            List<Map<String, Object>> otherDatas = new CopyOnWriteArrayList<>();

            class ComputeNext implements BiConsumer<StatementExecutionResult, Throwable> {

                int current;

                public ComputeNext(int current) {
                    this.current = current;
                }

                @Override
                public void accept(StatementExecutionResult result, Throwable error) {
                    if (error != null) {
                        ByteBuf errorMsg = composeErrorResponse(message.messageId, error);
                        _channel.sendReplyMessage(message.messageId, errorMsg);
                        message.close();
                        runningStatements.unregisterRunningStatement(statementInfo);
                        return;
                    }
                    if (result instanceof DMLStatementExecutionResult) {
                        DMLStatementExecutionResult dml = (DMLStatementExecutionResult) result;
                        Map<String, Object> otherData = Collections.emptyMap();
                        if (returnValues && dml.getKey() != null) {
                            TranslatedQuery translatedQuery = queries.get(current - 1);
                            Statement statement = translatedQuery.plan.mainStatement;
                            TableAwareStatement tableStatement = (TableAwareStatement) statement;
                            Table table = server.getManager().getTableSpaceManager(statement.getTableSpace()).getTableManager(tableStatement.getTable()).getTable();
                            Object key = RecordSerializer.deserializePrimaryKey(dml.getKey(), table);
                            otherData = new HashMap<>();
                            otherData.put("_key", key);
                            if (dml.getNewvalue() != null) {
                                Map<String, Object> newvalue = RecordSerializer.toBean(new Record(dml.getKey(), dml.getNewvalue()), table);
                                otherData.putAll(newvalue);
                            }
                        }
                        updateCounts.add(Long.valueOf(dml.getUpdateCount()));
                        otherDatas.add(otherData);
                    } else if (result instanceof DDLStatementExecutionResult) {
                        Map<String, Object> otherData = Collections.emptyMap();
                        updateCounts.add(Long.valueOf(1));
                        otherDatas.add(otherData);
                    } else {
                        ByteBuf response = PduCodec.ErrorResponse.write(message.messageId, "bad result type " + result.getClass() + " (" + result + ")");
                        _channel.sendReplyMessage(message.messageId, response);
                        message.close();
                        runningStatements.unregisterRunningStatement(statementInfo);
                        return;
                    }

                    long newTransactionId = result.transactionId;
                    if (current == queries.size()) {
                        try {
                            ByteBuf response = PduCodec.ExecuteStatementsResult.write(message.messageId, updateCounts, otherDatas, newTransactionId);
                            _channel.sendReplyMessage(message.messageId, response);
                            message.close();
                            runningStatements.unregisterRunningStatement(statementInfo);
                        } catch (Throwable t) {
                            t.printStackTrace();
                        }
                        return;
                    }

                    TranslatedQuery nextPlannedQuery = queries.get(current);
                    TransactionContext transactionContext = new TransactionContext(newTransactionId);
                    CompletableFuture<StatementExecutionResult> nextPromise
                            = server.getManager().executePlanAsync(nextPlannedQuery.plan, nextPlannedQuery.context, transactionContext);
                    nextPromise.whenComplete(new ComputeNext(current + 1));
                }
            }

            TransactionContext transactionContext = new TransactionContext(transactionId);
            TranslatedQuery firstTranslatedQuery = queries.get(0);
            server.getManager().executePlanAsync(firstTranslatedQuery.plan, firstTranslatedQuery.context, transactionContext)
                    .whenComplete(new ComputeNext(1));

        } catch (HerdDBInternalException  err) {
            ByteBuf response = composeErrorResponse(message.messageId, err);
            _channel.sendReplyMessage(message.messageId, response);
            message.close();
            runningStatements.unregisterRunningStatement(statementInfo);
        }
    }

    private void handleExecuteStatement(Pdu message, Channel _channel) {
        long txId = PduCodec.ExecuteStatement.readTx(message);
        String tablespace = PduCodec.ExecuteStatement.readTablespace(message);
        long statementId = PduCodec.ExecuteStatement.readStatementId(message);
        String query
                = statementId > 0 ? preparedStatements.resolveQuery(tablespace, statementId)
                        : PduCodec.ExecuteStatement.readQuery(message);
        if (query == null) {
            ByteBuf error = PduCodec.ErrorResponse.writeMissingPreparedStatementError(message.messageId, "bad statement id: " + statementId);
            _channel.sendReplyMessage(message.messageId, error);
            message.close();
            return;
        }
        boolean returnValues = PduCodec.ExecuteStatement.readReturnValues(message);

        PduCodec.ObjectListReader parametersReader = PduCodec.ExecuteStatement.startReadParameters(message);
        List<Object> parameters = new ArrayList<>(parametersReader.getNumParams());
        for (int i = 0; i < parametersReader.getNumParams(); i++) {
            parameters.add(parametersReader.nextObject());
        }
        if (LOGGER.isLoggable(Level.FINEST)) {
            LOGGER.log(Level.FINEST, "query {0} with {1}", new Object[]{query, parameters});
        }

        RunningStatementInfo statementInfo = new RunningStatementInfo(query, System.currentTimeMillis(), tablespace, "", 1);
        TransactionContext transactionContext = new TransactionContext(txId);
        TranslatedQuery translatedQuery = null;
        try {
            translatedQuery = server.getManager().getPlanner().translate(tablespace,
                    query, parameters, false, true, returnValues, -1);
        } catch (StatementExecutionException ex) {
            ByteBuf error = composeErrorResponse(message.messageId, ex);
            _channel.sendReplyMessage(message.messageId, error);
            message.close();
            return;
        }

        Statement statement = translatedQuery.plan.mainStatement;
//                    LOGGER.log(Level.SEVERE, "query " + query + ", " + parameters + ", plan: " + translatedQuery.plan);
        RunningStatementsStats runningStatements = server.getManager().getRunningStatements();
        runningStatements.registerRunningStatement(statementInfo);
        CompletableFuture<StatementExecutionResult> res = server
                .getManager()
                .executePlanAsync(translatedQuery.plan, translatedQuery.context, transactionContext);
//                    LOGGER.log(Level.SEVERE, "query " + query + ", " + parameters + ", result:" + result);
        res.whenComplete((result, err) -> {
            try {
                runningStatements.unregisterRunningStatement(statementInfo);
                if (err != null) {
                    while (err instanceof CompletionException) {
                        err = err.getCause();
                    }
                    if (err instanceof DuplicatePrimaryKeyException) {
                        ByteBuf error = composeErrorResponse(message.messageId, err);
                        _channel.sendReplyMessage(message.messageId, error);
                    } else if (err instanceof NotLeaderException) {
                        ByteBuf error = composeErrorResponse(message.messageId, err);
                        _channel.sendReplyMessage(message.messageId, error);
                    } else if (err instanceof StatementExecutionException) {
                        ByteBuf error = composeErrorResponse(message.messageId, err);
                        _channel.sendReplyMessage(message.messageId, error);
                    } else {
                        LOGGER.log(Level.SEVERE, "unexpected error on query " + query + ", parameters: " + parameters + ":" + err, err);
                        ByteBuf error = composeErrorResponse(message.messageId, err);
                        _channel.sendReplyMessage(message.messageId, error);
                    }
                    return;
                }
                if (result instanceof DMLStatementExecutionResult) {
                    DMLStatementExecutionResult dml = (DMLStatementExecutionResult) result;
                    Map<String, Object> newRecord = null;

                    if (returnValues && dml.getKey() != null) {
                        TableAwareStatement tableStatement = statement.unwrap(TableAwareStatement.class);
                        Table table = server
                                .getManager()
                                .getTableSpaceManager(statement.getTableSpace()).getTableManager(tableStatement.getTable()).getTable();
                        newRecord = new HashMap<>();
                        Object newKey = RecordSerializer.deserializePrimaryKey(dml.getKey(), table);
                        newRecord.put("_key", newKey);
                        if (dml.getNewvalue() != null) {
                            newRecord.putAll(RecordSerializer.toBean(new Record(dml.getKey(), dml.getNewvalue()), table));
                        }
                    }
                    _channel.sendReplyMessage(message.messageId,
                            PduCodec.ExecuteStatementResult.write(
                                    message.messageId, dml.getUpdateCount(), dml.transactionId, newRecord));
                } else if (result instanceof GetResult) {
                    GetResult get = (GetResult) result;
                    if (!get.found()) {
                        _channel.sendReplyMessage(message.messageId,
                                PduCodec.ExecuteStatementResult.write(
                                        message.messageId, 0, get.transactionId, null));
                    } else {
                        Map<String, Object> record = get.getRecord().toBean(get.getTable());
                        _channel.sendReplyMessage(message.messageId,
                                PduCodec.ExecuteStatementResult.write(
                                        message.messageId, 1, get.transactionId, record));
                    }
                } else if (result instanceof TransactionResult) {
                    TransactionResult txresult = (TransactionResult) result;
                    Set<Long> transactionsForTableSpace = openTransactions.computeIfAbsent(
                            RawString.of(statement.getTableSpace()), k -> new ConcurrentSkipListSet<>());
                    switch (txresult.getOutcome()) {
                        case BEGIN: {
                            transactionsForTableSpace.add(txresult.getTransactionId());
                            break;
                        }
                        case COMMIT:
                        case ROLLBACK:
                            transactionsForTableSpace.remove(txresult.getTransactionId());
                            break;
                    }
                    _channel.sendReplyMessage(message.messageId,
                            PduCodec.ExecuteStatementResult.write(
                                    message.messageId, 1, txresult.getTransactionId(), null));
                } else if (result instanceof DDLStatementExecutionResult) {
                    DDLStatementExecutionResult ddl = (DDLStatementExecutionResult) result;
                    _channel.sendReplyMessage(message.messageId,
                            PduCodec.ExecuteStatementResult.write(
                                    message.messageId, 1, ddl.transactionId, null));
                } else {
                    ByteBuf error = PduCodec.ErrorResponse.write(message.messageId, "unknown result type:" + result);
                    _channel.sendReplyMessage(message.messageId, error);
                }
            } finally {
                message.close();
            }
        });
    }

    private void handlePrepareStatement(Pdu message, Channel _channel) {
        try {
            String query = PduCodec.PrepareStatement.readQuery(message);
            String tablespace = PduCodec.PrepareStatement.readTablespace(message);
            TableSpaceManager tableSpaceManager = server.getManager().getTableSpaceManager(tablespace);
            if (tableSpaceManager == null) {
                ByteBuf error = PduCodec.ErrorResponse.write(message.messageId, "no such tablespace " + tablespace);
                _channel.sendReplyMessage(message.messageId, error);
                return;
            } else if (!tableSpaceManager.isLeader()) {
                ByteBuf error = PduCodec.ErrorResponse.writeNotLeaderError(message.messageId, "not leader for " + tablespace);
                _channel.sendReplyMessage(message.messageId, error);
                return;
            }
            long newId = preparedStatements.prepare(tablespace, query);
            _channel.sendReplyMessage(message.messageId,
                    PduCodec.PrepareStatementResult.write(
                            message.messageId, newId));
        } finally {
            message.close();
        }
    }

    private void handleTxCommand(Pdu message, Channel _channel) {
        long txId = PduCodec.TxCommand.readTx(message);
        int type = PduCodec.TxCommand.readCommand(message);
        String tableSpace = PduCodec.TxCommand.readTablespace(message);
        TransactionContext transactionContext = new TransactionContext(txId);
        Statement statement;
        switch (type) {
            case TX_COMMAND_COMMIT_TRANSACTION:
                statement = new CommitTransactionStatement(tableSpace, txId);
                break;
            case TX_COMMAND_ROLLBACK_TRANSACTION:
                statement = new RollbackTransactionStatement(tableSpace, txId);
                break;
            case TX_COMMAND_BEGIN_TRANSACTION:
                statement = new BeginTransactionStatement(tableSpace);
                break;
            default:
                statement = null;

        }
        if (statement == null) {
            ByteBuf error = PduCodec.ErrorResponse.write(message.messageId, "unknown txcommand type:" + type);
            _channel.sendReplyMessage(message.messageId, error);
            message.close();
        } else {
//            LOGGER.log(Level.SEVERE, "statement " + statement);
            CompletableFuture<StatementExecutionResult> res = server
                    .getManager()
                    .executeStatementAsync(statement, new StatementEvaluationContext(), transactionContext);
//                    LOGGER.log(Level.SEVERE, "query " + query + ", " + parameters + ", result:" + result);
            res.whenComplete((result, err) -> {
                try {
                    if (err != null) {
                        if (err instanceof NotLeaderException) {
                            ByteBuf error = composeErrorResponse(message.messageId, err);
                            _channel.sendReplyMessage(message.messageId, error);
                        } else if (err instanceof StatementExecutionException) {
                            ByteBuf error = composeErrorResponse(message.messageId, err);
                            _channel.sendReplyMessage(message.messageId, error);
                        } else {
                            LOGGER.log(Level.SEVERE, "unexpected error on tx command: ", err);
                            ByteBuf error = composeErrorResponse(message.messageId, err);
                            _channel.sendReplyMessage(message.messageId, error);
                        }
                    } else {
                        if (result instanceof TransactionResult) {
                            TransactionResult txresult = (TransactionResult) result;
                            Set<Long> transactionsForTableSpace = openTransactions.computeIfAbsent(
                                    RawString.of(statement.getTableSpace()), k -> new ConcurrentSkipListSet<>());
                            switch (txresult.getOutcome()) {
                                case BEGIN: {
                                    transactionsForTableSpace.add(txresult.getTransactionId());
                                    break;
                                }
                                case COMMIT:
                                case ROLLBACK:
                                    transactionsForTableSpace.remove(txresult.getTransactionId());
                                    break;
                            }
                            ByteBuf response = PduCodec.TxCommandResult.write(message.messageId, txresult.transactionId);
                            _channel.sendReplyMessage(message.messageId, response);
                        } else {
                            ByteBuf error = PduCodec.ErrorResponse.write(message.messageId, "unknown result type:" + result);
                            _channel.sendReplyMessage(message.messageId, error);

                        }
                    }
                } finally {
                    message.close();
                }
            });
        }
    }

    private void handleSaslTokenMessage(Pdu message, Channel _channel) {
        try {
            if (saslNettyServer == null) {
                ByteBuf error = PduCodec.ErrorResponse.write(message.messageId, "Authentication failed (SASL protocol error)");
                _channel.sendReplyMessage(message.messageId, error);
                return;
            }
            byte[] token = PduCodec.SaslTokenMessageToken.readToken(message);
            byte[] responseToken = saslNettyServer.response(token);
            ByteBuf tokenChallenge = PduCodec.SaslTokenServerResponse.write(message.messageId, responseToken);
            if (saslNettyServer.isComplete()) {
                username = saslNettyServer.getUserName();
                authenticated = true;
                LOGGER.log(Level.INFO, "client {0} connected as {1}", new Object[]{channel.getRemoteAddress(), username});
                saslNettyServer = null;
            }
            _channel.sendReplyMessage(message.messageId, tokenChallenge);
        } catch (Exception err) {
            if (err instanceof javax.security.sasl.SaslException) {
                LOGGER.log(Level.SEVERE, "SASL error " + err, err);
                ByteBuf error = PduCodec.ErrorResponse.write(message.messageId, "Authentication failed (SASL error)");
                _channel.sendReplyMessage(message.messageId, error);
            } else {
                LOGGER.log(Level.SEVERE, "Bad auth error " + err, err);
                ByteBuf error = composeErrorResponse(message.messageId, err);
                _channel.sendReplyMessage(message.messageId, error);
            }
        }
    }

    private void handleSaslTokenMessageRequest(Pdu message, Channel _channel) {
        try {
            String mech = PduCodec.SaslTokenMessageRequest.readMech(message);
            byte[] token = PduCodec.SaslTokenMessageRequest.readToken(message);
            if (token == null) {
                token = new byte[0];
            }
            if (saslNettyServer == null) {
                saslNettyServer = new SaslNettyServer(server, mech);
            }
            byte[] responseToken = saslNettyServer.response(token);
            ByteBuf tokenChallenge = PduCodec.SaslTokenServerResponse.write(message.messageId, responseToken);
            _channel.sendReplyMessage(message.messageId, tokenChallenge);
        } catch (Exception err) {
            ByteBuf error = composeErrorResponse(message.messageId, err);
            _channel.sendReplyMessage(message.messageId, error);
        }
    }

    @Override
    public void channelClosed(Channel channel) {
        LOGGER.log(Level.INFO, "channelClosed {0}", this);
        freeResources();
        this.server.connectionClosed(this);
    }

    private void freeResources() {
        if (!openTransactions.isEmpty()) {
            LOGGER.log(Level.SEVERE, "freeResources {0}, {1} open transactions", new Object[]{this, openTransactions.size()});
            for (Map.Entry<RawString, Set<Long>> openTransaction : openTransactions.entrySet()) {
                RawString tableSpace = openTransaction.getKey();
                for (Long tx : openTransaction.getValue()) {
                    try {
                        LOGGER.log(Level.SEVERE, "rolling back trasaction tx=" + tx + " on tablespace " + tableSpace);
                        RollbackTransactionStatement statement = new RollbackTransactionStatement(tableSpace.toString(), tx);
                        StatementExecutionResult result = server.getManager().executeStatement(statement, StatementEvaluationContext.DEFAULT_EVALUATION_CONTEXT(), TransactionContext.NO_TRANSACTION);
                        LOGGER.log(Level.SEVERE, "rollback outcome trasaction tx=" + tx + " on tablespace " + tableSpace + ": " + result);
                    } catch (Throwable t) {
                        LOGGER.log(Level.SEVERE, "error while rolling back trasaction tx=" + tx + " on tablespace " + tableSpace + " :" + t, t);
                    }
                }
            }

            openTransactions.clear();
        }
        scanners.values().forEach(s -> s.close());
        scanners.clear();
    }

    ConnectionsInfo.ConnectionInfo toConnectionInfo() {
        return new ConnectionsInfo.ConnectionInfo(id + "", connectionTs, username, address);
    }

    @Override
    public String toString() {
        return "ServerSideConnectionPeer{" + "id=" + id + ", channel=" + channel + ", address=" + address + ", username=" + username + '}';
    }

}
